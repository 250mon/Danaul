import pandas as pd
from typing import Dict, List
from PySide6.QtCore import Qt, QModelIndex
from model.di_data_model import DataModel
from common.d_logger import Logs
from constants import EditLevel
from common.datetime_utils import *
from constants import RowFlags


logger = Logs().get_logger("main")


class PatientModel(DataModel):
    def __init__(self, user_name: str):
        self.init_params()
        super().__init__(user_name)

    def init_params(self):
        self.set_table_name('patients')

        self.col_edit_lvl = {
            'patient_id': EditLevel.NotEditable,
            'patient_emr_id': EditLevel.AdminModifiable,
            'patient_name': EditLevel.AdminModifiable,
            'patient_gender': EditLevel.AdminModifiable,
            'patient_birthdate': EditLevel.AdminModifiable,
            'flag': EditLevel.NotEditable
        }

        self.set_column_names(list(self.col_edit_lvl.keys()))
        self.set_column_index_edit_level(self.col_edit_lvl)

    def set_add_on_cols(self) -> None:
        """
        Needs to be implemented in the subclasses
        Adds extra columns of each name mapped to ids of supplementary data
        :return:
        """
        # set more columns for the view
        self.model_df['flag'] = RowFlags.OriginalRow

    def get_default_delegate_info(self) -> List[int]:
        """
        Returns a list of column indexes for default delegate
        :return:
        """
        columns_for_delegate = ['patient_name', 'patient_gender']
        delegate_info = [self.get_col_number(c) for c in columns_for_delegate]
        return delegate_info

    def get_combobox_delegate_info(self) -> Dict[int, List]:
        """
        Returns a dictionary of column indexes and val lists of the combobox
        for combobox delegate
        :return:
        """
        delegate_info = {
            self.get_col_number('patient_gender'): ["M", "F"]
        }
        return delegate_info

    def get_dateedit_delegate_info(self) -> Dict[int, date]:
        """
        Returns a dictionary of column indexes and val lists of the spinbox
        for spinbox delegate
        :return:
        """
        delegate_info = {
            self.get_col_number('patient_birthdate'): date(2000, 6, 15)
        }
        return delegate_info

    def data(self, index: QModelIndex, role=Qt.DisplayRole) -> object:
        """
        Override method from QAbstractTableModel
        QTableView accepts only QString as input for display
        Returns data cell from the pandas DataFrame
        """
        if not index.isValid():
            return None

        col_name = self.get_col_name(index.column())
        data_to_display = self.model_df.iloc[index.row(), index.column()]
        if role == Qt.DisplayRole or role == Qt.EditRole or role == self.SortRole:
            if col_name == 'patient_birthdate':
                return pydt_to_qdt(data_to_display)
            else:
                return str(data_to_display)
        elif role == Qt.TextAlignmentRole:
            left_aligned = ['description']
            if col_name in left_aligned:
                return Qt.AlignLeft
            else:
                return Qt.AlignCenter
        else:
            return super().data(index, role)

    def setData(self,
                index: QModelIndex,
                value: object,
                role=Qt.EditRole):
        """
        Override method from QAbstractTableModel
        :param index:
        :param value:
        :param role:
        :return:
        """
        if not index.isValid() or role != Qt.EditRole:
            return False

        logger.debug(f"index({index}), value({value})")

        col_name = self.get_col_name(index.column())
        if col_name == 'patient_birthdate':
            # data type is datetime.date
            if isinstance(value, QDateTime):
                value = qdt_to_pydt(value)

        return super().setData(index, value, role)

    def make_a_new_row_df(self, next_new_id, **kwargs) -> pd.DataFrame:
        """
        Needs to be implemented in subclasses
        :param next_new_id:
        :return: new dataframe if succeeds, otherwise raise an exception
        """
        new_model_df = pd.DataFrame([{
            'patient_id': next_new_id,
            'patient_emr_id': 0,
            'patient_name': '',
            'patient_gender': 'M',
            'patient_birthdate': date(2010, 6, 15),
            'flag': RowFlags.NewRow
        }])
        return new_model_df


def validate_new_row(self, index: QModelIndex) -> bool:
    """
    This is used to validate a new row generated by SingleItemWindow
    when the window is done with creating a new row and emits add_item_signal
    :param index:
    :return:
    """
    emr_id_col = self.get_col_number('patient_emr_id')
    emr_id = index.siblingAtColumn(emr_id_col).data()
    if (emr_id is not None and
            emr_id != "" and
            emr_id not in self.model_df['patient_emr_id']):
        logger.debug(f"patient_emr_id ({emr_id}) is valid")
        return True
    else:
        logger.debug(f"patient_emr_id ({emr_id}) is not valid")
        return False
